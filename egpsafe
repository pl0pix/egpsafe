#!/bin/bash
#set -x
#
# Written by Ben Reser <ben@reser.org>
# Shell script to decrypt a file to a temp file.  Edit it.
# Re-encrypt the file and then wipe the temp file from the drive.
# requires gpg and wipe.
# * added secure way of generating a tmp file. -- erik@code.de
# * added handling of an alternate place for gpg and password file
#   for usb memory stick handling -- erik@code.de
# * added darwin support -- erik@code.de
# * added encryption for one or more recipients -- erik@code.de
#
# END OF CHANGELOG

PROGRAM=`basename "$0"`
VERSION="%%VERSION%%"
DEBUG=${DEBUG:=0}

# Shorten PATH to standard pathes for invoking user. This is for security.
PATH="/bin:/usr/bin"

# specify recipients who are able to decrypt your password file This is useful
# for people with a private gpg key and different gpg key for business.
# The recipient key must already imported in used keychain. Do not enter a
# key with spaces. They are currently not supported.
RECIPIENT_KEY_ID=0x720DF241

# password base filename it gets the .gpg extension on encryption
PASSWORD_FILE=".passwords"

# specify the point where the usb stick is mounted
MOUNTPOINT=/media/sda1
# specify path to encrypted password file (relative to MOUNTPOINT) so: no
# leading /
USB_PASSWORD_DIR=""
# If USB memory device is mounted, it uses gpg key on that device
USB_GNUPG_DIR=".gnupg/"
 
## Merge variables
# remote (hup) path to password file
# check scp(1) man page for URL syntax
SCP_OPTIONS="-Bqp"
HUP_PASSWORD_FILE="10.9.9.2:/home/erik/.password.gpg"

## Global vars
# check for OS and their defaults
_uname=`uname`
case "$_uname" in
	Linux*)
		PASSWORD_DIR=${HOME}
		PATH=/bin:/usr/bin
		MERGE_BIN="meld"
		;;
	Darwin*)
		PASSWORD_DIR=${HOME}
		# added path to common package installations and macports 
		PATH=${PATH}:/usr/local/bin:/opt/local/bin
		MERGE_BIN="opendiff"
		;;
        *)
		# If you discover new shells that can't handle dev tty etc. as
		# below, then tailor it here.
		echo Platform not supported >&2
		exit 1
		;;
esac

EDITOR=${EDITOR:=vi}
PAGER=${PAGER:=view}
GPGFILE_EXTENSION=${GPGFILE_EXTENSION:-.gpg}
GPGFILE=${PASSWORD_DIR}/${PASSWORD_FILE}${GPGFILE_EXTENSION}

## Functions

usage ()
{
	cat <<EOFUSAGE
Usage: $PROGRAM [-hVv] edit|see|search|merge

DESCRIPTION
	stores your passwords in a gpg encrypted file.

OPTIONS
	-h this information
	-V prints version end exits
	-v enable verbose output
        -D enable debug mode

MODES
	edit (default mode)
		Add or change passwords in file (default: $EDITOR)
	see
		Read-only access to password file (default: $PAGER)
	search
		Search for pattern in file
	merge
		Merge to a hup/spoke using scp

EXITCODES
        1 error in options
        2 can not decrypt file
        3 can not encrypt file

BUGS
Send bug reports to Erik Wenzel <ew@code.de>
EOFUSAGE
}

# function:    echos a error message to /dev/stderr
# parameter:   $@ = additional information
msgError ()
{
	echo $PROGRAM: "$@" >&2
}

# function:   for echoing a message on a non zero exit status of a process 
#             to stderr. Exit code are 1 >= 255.
# parameters: $1 = process name, $2 = exit status number
msgOnFailedExitStatus ()
{
	if [ $2 -ge "1" -a $2 -le "255" ]
	then
		echo "Process $1 return exit status $2. Exiting..." >&2
		exit $2
	fi
}

# function:   echos a debugging string to stderr if debug flag is enabled
# parameters: $1 = value of debugging flag, $* = debugging string
msgDebug ()
{
	debugString="$*"
	# "${debugString#* }" removes first argument, which is the debug level.
	[ $1 -le $DEBUG ] && echo "DEBUG${1}: ${debugString#* }" >&2
}

msgVerbose ()
{
        echooption=""
        if [ "X$1" = "X-n" ]
        then
                echooption="-n"
                shift
        fi
        if [ "X$option_verbose" = "Xyes" ]
        then
                msgDebug 9 echo option: $echooption everything else: "$*"
                echo $echooption "$*"
        else
                msgDebug 9 verbose option not enabled
        fi
}

#function:    echos a error message on verbose flag
#parameters:  $* additional information
msgVerboseError ()
{
	if [ "X$option_verbose" = "Xyes" ]
	then
		msgError "$*"
	fi
}

#function     os independent mktemp creation
#
_mktemp ()
{
	_uname=`uname`
	local $TEMPFILE
	case "$_uname" in
	Linux*)
		TEMPFILE=`mktemp -p ${TMPDIR:-/tmp} ${PROGRAM}.XXXXXXXX`
		;;
	Darwin*)
		TEMPFILE=`mktemp -t ${PROGRAM}.XXXXXXXX`
		;;
	*)
		# If you discover new shells that can't handle dev tty etc. as
		# below, then tailor it here.
		echo Platform not supported >&2
		exit 1
		;;
	esac
	msgDebug 1 TEMPFILE: $TEMPFILE
	echo $TEMPFILE
}

# Arg: $1 = filename $2 = output $TMPFILE
gpg_decrypt ()
{
	# if optional $2 is an other file then $TMPFILE
	if [ X$2 != "X" ]
	then
		TMPFILE=$2
	fi
	msgDebug 1 writing cleartext file to: $TMPFILE
	# last option _must_ be --decrypt. do not reorder options
	gpg --homedir ${HOMEDIR} --yes --output "$TMPFILE" --decrypt $1
}

# Arg: $1 = output filename $2 input tmpfile (optional)
gpg_encrypt ()
{
	if [ "x$RECIPIENT_KEY_ID" = "x" ]
	then
		RECIPIENTS_OPTS=" --default-recipient-self "
		msgDebug 1 No receipient key found, encrypting to my self only
	else
		# get default recipient on currently used keyring
		RECIPIENTS_OPTS="-r 0x`gpg --list-key | head -n6 | grep "^pub" | cut -d" " -f4 | cut -d/ -f2`"
		RECIPIENTS_OPTS="${RECIPIENTS_OPTS} -r $RECIPIENT_KEY_ID"
		msgDebug 1 Found recipient key
	fi
	if [  x$2 = "x" ]
	then
		gpg --homedir ${HOMEDIR} --yes --trust-model always $RECIPIENTS_OPTS --encrypt $1
	else
		gpg --homedir ${HOMEDIR} --yes --trust-model always --output $1 \
		$RECIPIENTS_OPTS --encrypt $2
	fi
}

check_usb_device ()
{
	# check if usb memory is mounted. Then use gpg key on usb device.
	if [ -d ${MOUNTPOINT} ]
	then
		msgDebug 1 Found a mounted USB Memory Stick
		PASSWORD_DIR=${MOUNTPOINT}/${USB_PASSWORD_DIR}
		HOMEDIR=${MOUNTPOINT}/${USB_GNUPG_DIR}
	else
		# go with standard installation
		msgDebug 1 No USB device found\; Using default gpg key
		PASSWORD_DIR=$HOME
		HOMEDIR=${HOME}/.gnupg
	fi
}

# no arguments returns the path to encrypted password file
copy_from_hup ()
{
	HUP_TEMPFILE=`_mktemp`
	scp $SCP_OPTIONS $HUP_PASSWORD_FILE $HUP_TEMPFILE
	if [ $? = 0 ]
	then
		echo $HUP_TEMPFILE
	fi
}

# Arg: $1 = encrypted local file to be copied to hup
copy_to_hup ()
{
	scp $SCP_OPTIONS $1 $HUP_PASSWORD_FILE
	msgOnFailedExitStatus File $1 can not be copied to hup.
	return 1
}


cleanup ()
{
	if `which wipe`
	then
		wipe -f -s $TMPFILE 
		if [ -f $HUP_TEMPFILE ]
		then
			wipe -f -s $HUP_TEMPFILE
		fi
	else
		rm -f $TMPFILE
		if [ -f $HUP_TEMPFILE ] 
		then 
			rm -f $HUP_TEMPFILE
		fi
		msgVerbose "TMPFILE only removed -- NOT secure! Install: wipe"
	fi
}

#
## MAIN
#
TMPFILE=`_mktemp`
SEARCH_PATTERN=""

# use bash builtin getopts
while getopts DVvh name
do
        case $name in
                D) DEBUG=1
		;;
                h) usage
                   exit 0
		;;
                V) echo $VERSION
                   exit 0
		;;
                v) option_verbose="yes"
		;;
                ?) usage
                   exit 1
		;;
        esac
done

#shift $(($OPTIND - 1))
# SunOS 5.8 /bin/sh doesn't know $(()) and $() expressions. See "C1" in FAQ.gz
#  from bash package for a complete list of differences between sh and bash.
shift `expr $OPTIND - 1`

check_usb_device

# Initializing files on the first run
msgDebug 1 Using GPGFILE: $GPGFILE
if [ ! -f $GPGFILE ]
then
	touch $GPGFILE
	TMP_CLEARTEXT_FILE=`_mktemp`
	msgVerbose Created candidate cleartext password file. Save it and it will be encrypted.
	$EDITOR $TMP_CLEARTEXT_FILE
	gpg_encrypt $TMP_CLEARTEXT_FILE && msgVerbose $GPGFILE created.
	msgDebug 1 No encrypted file found: Created $GPGFILE
	rm -f $TMP_CLEARTEXT_FILE
fi

msgDebug 1 \$1 has value: $1
msgDebug 1 \$* has value: $*
#
# Now process all values of $0
case $1 in
	edit)
		# Default mode
		:
	;;
	see)
		EDITOR=$PAGER
	;;
	merge)
		set -x
		TMP_HUP_DECRYPT_FILE=`_mktemp`
		# copy_from_hup returns path to hup_tempfile
		HUP_GPGFILE=`copy_from_hup`
		# compare ctimes of both files. The new one is printed first
		# 
		newer_file=`ls -tc $HUP_GPGFILE $GPGFILE | head -1`
		if [ $newer_file = $HUP_GPGFILE ]
		then
			:
			msgVerbose Password file on Remote Host is newer
		else
			:
			msgVerbose Password file on local Host is newer
		fi
		# if not empty
		if [ X$HUP_GPGFILE != "X" ]
		then
			if gpg_decrypt $HUP_GPGFILE $TMP_HUP_DECRYPT_FILE
			then
				read -p 'Hup file is left, local file is right. ok?[Y/n]' REPLY
				if [ $REPLY = 'n' -o $REPLY = 'N' ]
				then
					msgDebug 1 Exit merge mode 
					break
				fi
				### FIXME merge tool doesn't start
				$MERGE_BIN $TMP_HUP_DECRYPT_FILE `gpg_decrypt $GPGFILE`
			fi
		fi
		# Be careful which file was written
		newer_file=`ls -tc $TMP_HUP_DECRYPT_FILE $TMPFILE`
		msgVerbose last written file: $newer_file
		# check for differences after merge
		if diff -q >/dev/null
		then
			# reencrypt and scp file to hup
			if gpg_encrypt $GPGFILE $TMPFILE
			then
				msgDebug 1 Successfully encrypted $GPGFILE
				copy_to_hup $GPGFILE
			fi
		else
			msgDebug 1 Something went wrong. Try to fix it.
			echo Merged files still differ.
			echo ---
			echo Entering interactive mode to resolve confusion. What to do next:
			echo '[m]erge again,'
			echo 'upload [n]ewer file to hup,'
			echo '[s]ave local file and remove file from hup. Do not copy to hup,'
			echo '[d]o nothing just continue; everything is fine'
			read -p'mnosd [m]>' REPLY
			case $REPLY in
			n)
				if [ $newer_file = $HUP_GPGFILE ]
				then
					if gpg_encrypt $HUP_GPGFILE $TMP_HUP_DECRYPT_FILE
					then
						msgDebug 1 Successfully encrypted $HUP_GPGFILE
						copy_to_hup $HUP_GPGFILE
					fi
				else
					if gpg_encrypt $GPGFILE $TMPFILE
					then
						msgDebug 1 Successfully encrypted $GPGFILE
						copy_to_hup $GPGFILE
					fi
				fi
			;;
			d) :
			;;
			s)	if gpg_encrypt $GPGFILE $TMPFILE
				then
					msgDebug 1 Successfully encrypted $GPGFILE
					copy_to_hup $GPGFILE
				fi
			;;
			m|*) $MERGE_BIN $TMP_HUP_DECRYPT_FILE `gpg_decrypt $GPGFILE`
			;;
			esac
		fi
	;;
	search)
		if [ "X" != "X$*" ]
		then
			# all characters following "search " are pattern
			SEARCH_PATTERN="$*"
		fi
	;;
	*)
		msgDebug 1 No Mode specified using default mode: edit
	;;
esac

exit 0
if gpg_decrypt $GPGFILE
then
	msgDebug 1 Successfully decrypted $GPGFILE
	if [ "X$SEARCH_PATTERN" != "X" ]
	then
		$EDITOR +/"$SEARCH_PATTERN" $TMPFILE
		exit 13
	fi
	$EDITOR $TMPFILE

	if gpg_encrypt $GPGFILE $TMPFILE
	then
		msgDebug 1 Successfully encrypted $GPGFILE
		cleanup
	else
		echo -ne \007
		msgError "Warning could not re-encrypt $TMPFILE";
		exit 3
	fi
else
	msgError "Couldn't decrypt $GPGFILE"
	exit 2
fi

trap 'cleanup; exit 13' 1 2 3 15
exit 0

